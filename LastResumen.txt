NET Framework: 
sólo funciona en Windows. ultima versión: 4.8 en abril 2019. Con él se pueden crear las siguientes aplicaciones:
-Console Apps
-Windows Communications Foundations (WCF): comunicación de servidores web
-Windows Workflow Foundation (WF) automatizar procesos de negocios
-Windows Presentation Foundation (WPF): aplicaciones de escritorio con complejas UI
-Windows Form: aplicaciones de escritorio sencillas
-ASP .NET: aplicaciones web con Web Forms, Web API o MVC
-Azure
OBJETIVO: Apps de escritorio para Windows

NET Core:
framework multiplataforma y más liviano que NET Framework. Tiene sólo las librerías necesarias, y sino se instalan paquetes NuGet.
 Es totalmente side-by-side (varias versiones pueden correr en la misma PC) y permite realizar apps self-contained (con Net Core incorporado). Con él se pueden crear las siguientes aplicaciones:
-Console Apps
-ASP.Net Core: MVC y API (evolución de NET Framework)
-UWP: para apps de escritorio
OBJETIVO: Apps multiplataforma (web y escritorio)

Mono for Xamarin:
Runtime para crear apps móviles.
OBJETIVO: Apps móviles multiplataforma

RUNTIME: código necesario para que corra el lenguaje de la app.

Net Standard:
set de especifiaciones que indica qué funciones (implementadas APIs) se pueden usar en todas las plataformas.
 Cada runtime específico implementa una versión específica de Net Standard. (ejemplo: .Net Framework 4.5 implementa Net Standard 1.1).
Su propósito principal es compartir código entre runtimes. Si quiero crear librerías de clases, debo usar una versión de Net Standard implementada por mis runtimes objetivo.

Microsoft decidió unificar los diferentes runtimes en un único framework. Por eso creó .NET 5 en 2020 con el objetivo de sacar una versión por año (vamos por el 7)

			MODELO CLIENTE-SERVIDOR:

Modelo que permite la distribución de tareas dentro de una red de ordenadores.
 Un servidor es un hardware que proporciona los recursos necesarios para otros ordenadores o programas o un programa informático que se comunica con los clientes. 
Las normas que definen esa comunicación son protocolos.
Este modelo tiene una administración central ya que el servidor está en el centro de la red y todos los recursos importantes se encuentran en él.
Desventajas: si se cae el server, se cae todo el sistema. Para eso hay arquitecturas multi-servidor. 
Si un servidor se ve comprometido, el servicio ofrece alguno de los otros (técnica conocida como "mirroring").

		ARQUITECTURA POR CAPAS (TRES CAPAS):

Una capa es un conjunto de "cosas" que tienen cierta responsabilidad (ejemplo: un conjunto de clases). Esta arquitectura establece 2 reglas:
1: Cada capa debe tener una responsabilidad única.
2: Las capas deben respetar una estructura jerárquica estrícta. Cada capa puede comunicarse sólo con la que está inmediatamente debajo suyo, pero NO al revés. No se pueden saltar capas.
VENTAJAS: fácil de testear cada capa por la división de responsabilidades. Además, ante un cambio, sólo se afecta a la capa en que se implementó.
DESVENTAJAS: Si hay muchas capas, afecta al rendimiento de la app. Además, la modificación de ciertas operaciones puede afectar a todas las capas.
TRES CAPAS (la arquitectura más común):
-Presentación: atiende los eventos del cliente. Si el cliente es un humano, atiende los clicks en un HTML. Si es otro sistema, atiende peticiones REST.
-Lógica de negocio: contiene los requerimientos funcionales del sistema,
-Acceso a datos: permite obtener o guardar datos de la app.

API (Application Programming Interface):
Una API es una interfaz para que programas de software se comuniquen entre ellos y compartan datos bajo diferentes estándares. 
Las APIs pueden ser locales o remotas.
 Las remotas utilizan un servicio web y sus arquitecturas pueden ser SOAP (Simple Object Access Protocol) o REST.
 El más común es REST: Representational State Transfer.
 Generalmente los archivos de info enviados y recibidos son JSON.
 Las APIs pueden ser públicas o privadas.
 Las privadas requieren autenticación mediante TOKEN (contiene un objeto cifrado).

REQUEST-RESPONSE:
Patrón de intercambio de mensajes. Es muy común en arquitecturas cliente-servidor.
 El patrón puede ser sincrónico o asincrónico. Las request y responses tienen una forma específica dada por el protocolo HTTP o HTTPS.
Las requests se hacen siempre a un ENDPOINT: un punto de acceso de una API que procesa la request y responde de acuerdo a su implementación interna (encapsulación).
 Las requests y responses están compuestas por:

		REQUEST:
-Método: GET, POST, PUT, etc. (verbo HTTP). Indica el tipo de request.
-Path: la URL que se solicita, donde se encuentra el resource (recurso).
-Protocolo: contiene HTTP y su versión.
-Headers: son esquemas de key: value (llave-valor) que contienen información sobre la HTTP request y el navegador. También incluye datos de cookies. La mayoría de headers son opcionales.
-Body: Si se envía info al servidor (POST o PUT), va en el body.

		RESPONSE:

-Protocolo: contiene HTTP y su versión.
-Status code: código de respuesta. EJEMPLOS: 200 OK (solicitud satisfactoria), 404 Not Found (el servidor no encontró el resource), 403 Forbidden (el cliente tine credenciales válidas pero no posee permisos o privilegios necesarios para cierto contenido),  400 Bad Request (solicitud errónea), 401 Unauthorized (faltan credenciales de autenticación válidas para el resource o son inválidas), 500 Internal Server Error (El servidor no puede completar la request por un problema inesperado), etc.
-Headers: contienen info sobre el software del servidor, última modificación del resource solicitado, etc. La mayoría son opcionales.
-Body: info que devuelva el servidor (que no sean headers).



					VERBOS HTTP (más importantes):

-GET: solicita una representación de un recurso específico,
-POST: Envía una entidad a un recurso específico. Se suele usar para crear un nuevo recurso,
-PUT: reemplaza todas las representaciones actuales del recurso de destino con la carga útil de la petición. Hace una modificación total de un recurso,
-DELETE: borra un recurso específico,
-PATCH: aplica modificaciones parciales a un recurso.
___________________________________________________________________________________________________________________________________________


					MVC (Model View Controller):

Patrón de arquitectura de software para separar el código por sus distintas responsabilidades, en 3 capas: Modelos Vistas y Controladores.

-Modelos: capa donde se trabaja con los datos. Contiene mecanismos para acceder y actualizar información.
 Se suele utilizar librerías o algún ORM como Entity Framework para la abstracción de bases de datos y persistencia en objetos. Contiene la lógica de negocio.

-Vistas: código que va a producir la visualización de interfaces de usuario en HTML.
-Controladores: código para responder a las acciones que se solicitan en la app: visualizar un elemento, realizar una compra, etc. Enlace entre las vistas y los modelos. Contiene la lógica de aplicación.

En el patrón de diseño MVC (Modelo-Vista-Controlador) que se utiliza en .NET y otros frameworks, el controlador es responsable de manejar la lógica de la aplicación, pero no la lógica del negocio.
La lógica de la aplicación se refiere a cómo se manejan las solicitudes del usuario.
 cómo se interactúa con el modelo y cómo se selecciona la vista correcta para mostrar al usuario. 
Por ejemplo, si un usuario hace clic en un botón para ver su perfil, el controlador determinará qué datos del modelo se necesitan
 (como el nombre del usuario y la foto del perfil) y seleccionará la vista de perfil para mostrar estos datos.

Por otro lado, la lógica del negocio se refiere a las reglas y operaciones específicas de la empresa o del dominio del problema.
 Por ejemplo, si estás construyendo una aplicación de comercio electrónico, la lógica del negocio podría incluir cosas como calcular el total de un carrito de compras.
aplicar descuentos o procesar pagos. Esta lógica del negocio generalmente se maneja en el modelo o en una capa de servicio separada, no en el controlador.

El controlador en .NET se encarga de coordinar el modelo y la vista basándose en las acciones del usuario, pero no implementa las reglas y operaciones específicas del negocio.

___________________________________________________________________________________________________________________________________________


En ASP.NET, los datos pueden llegar a los controladores de varias formas, y se utilizan diferentes atributos para indicar de dónde debe obtenerse cada parámetro:


[FromBody]: Este atributo indica que el parámetro debe leerse del cuerpo de la solicitud HTTP. Se utiliza comúnmente con datos JSON.
[FromQuery]: Este atributo indica que el parámetro debe leerse de la cadena de consulta de la URL
[FromRoute]: Este atributo indica que el parámetro debe leerse de la ruta de la URL
[FromForm]: Este atributo se utiliza para los datos que se envían desde un formulario HTML

___________________________________________________________________________________________________________________________________________


				Inyección de dependencias: 

 La inyección de dependencias es una técnica que permite a un objeto proporcionar las dependencias de otro objeto.
 En lugar de que las clases creen sus propias dependencias, estas se inyectan cuando la clase se crea.
 Esto permite que el código sea más reutilizable, más fácil de probar y menos acoplado. En .NET, la inyección de dependencias es una parte integrada del marco.


___________________________________________________________________________________________________________________________________________

Tipos de respuestas HTTP:	estado HTTP más comunes que puedes encontrar en ASP.NET:


200 OK: La solicitud ha tenido éxito.
201 Created: La solicitud ha tenido éxito y se ha creado un nuevo recurso como resultado.
204 No Content: La solicitud ha tenido éxito, pero no hay representación que devolver (es decir, el cuerpo está vacío).
400 Bad Request: La solicitud no se pudo entender o no se pudo procesar.
401 Unauthorized: La solicitud requiere autenticación. El cliente debe pasar credenciales de autenticación5.
403 Forbidden: El cliente no tiene permisos para acceder al recurso.
404 Not Found: No se pudo encontrar el recurso solicitado.
500 Internal Server Error: El servidor encontró una condición inesperada que le impidió cumplir con la solicitud




___________________________________________________________________________________________________________________________________________

					DIAGRAMA DE CLASES:
	
Es un diagrama puramente orientado al modelo de POO, ya que define las clases que se utilizarán y las relaciones entre ellas. Este diagrama está formado por dos elementos: CLASES y RELACIONES.
CLASES: representa una clase dentro del paradigma POO. Normalmente representa entidades o conceptos del "negocio."
 Una clase define un grupo de objetos que comparten características, condiciones y significado.
 Para encontrarlas, es buena práctica buscar los sustantivos del enunciado:
 Animal, Persona, Mensaje, etc. 
Una clase está compuesta por tres elementos: nombre, atributos y funciones.

 Pueden o no representarse en el diagrama. La clase es una caja dividida en tres zonas: la primera tiene el nombre, la segunda los atributos y la tercera las funciones.

RELACIONES: identifica una dependencia. Puede ser entre dos o más clases (más común) o una clase hacia sí misma (dependencia reflexiva). 

Las relaciones se representan con una línea que une las clases. Las relaciones tienen las siguientes características:
-Multiplicidad: el número de elementos de una clase que participan en una relación (se utiliza N o * para un número cualquiera),
-Nombre de la asociación: Ayuda a entender la relación y suelen ser verbos (una empresa contrata a n empleados).

				TIPOS PRINCIPALES DE RELACIONES:

-Asociación: línea común y continua: "Una mascota pertenece a una persona",
-Agregación o composición: indica a un objeto y las partes que lo componen. Es una línea con un rombo del lado de la clase contenedora: "Las mesas están formadas por tornillos",
-Dependencia: indica que una clase requiere de otra para funcionar. Es una línea discontinua que sale desde la clase que necesita a la otra,
-Herencia: línea de flecha que va desde la clase hija a la clase padre.
 
El diagrama de clases suele graficarse a partir de una minuta de relevamiento.
 Para graficarlo, se utiliza el lenguaje UML (Unified Model Language) para el análisis y diseño orientado a objetos.
 Una buena metodología de desarrollo de software que utiliza UML es UP (Unified Process o proceso unificado) que se destaca por el desarrollo iterativo. 
El desarrollo se organiza en una serie de mini proyectos cortos de duración fija llamados iteraciones. El resultado de cada uno es un sistema que puede ser probado, integrado y ejecutado.

			
		PROGRAMACIÓN ORIENTADA A OBJETOS Y PRINCIPIOS FUNDAMENTALES:

-Encapsulación: característica de un lenguaje POO que permite que todo los datos de un objeto queden aislados dentro de él. 
Sólo se puede acceder a ellos a través de los miembros que la clase proporciona (propiedades y métodos).

-Abstracción: la clase debe representar las características de la entidad hacia el mundo exterior pero ocultando su complejidad.
 Una clase debe exponer sólo lo que sea necesario para su uso. Lo que se hace por dentro de esa clase es irrelevante.

-Herencia: permite que una clase derivada o hija herede de una clase base o padre. 
La hija obtiene todos los rasgos del padre, añade otros nuevos y permite modificar algunos de los heredados (override en C#).

-Polimorfismo: permite que una clase hija pueda redefinir un método de la clase padre. 
Para ello utilizamos el atributo "override" en C#. El método a sobreescribir de la clase padre debe llevar el atributo "virtual" para poder aplicarle un "override" desde la clase hija.

___________________________________________________________________________________________________________________________________________


Debido a que los tiempos están cambiando, las empresas, gracias a dios, ya no realizan una aplicación gigantesca que lo hace todo, sino que esa misma aplicación está dividida en diferentes módulos o pequeños proyectos que realizan cada uno una función específica.

El uso de pequeños proyectos para hacer una aplicación más grande la denominamos arquitectura de microservicios.

 los microservicios se nutren o se basan en APIs

							QUE ES UNA API?

 Una API es el punto de entrada del exterior a tu proyecto.
Por supuesto lo mismo se aplica cuando nosotros somos los que consumimos diferentes API’s.
"tenemos nuestro front end, el cual consume al back end a través de una API, y a su vez el back end consume otros dos servicios a través de APIs."
- Tipos de API en C#
En C# disponemos de dos opciones para crear APIs los cuales son SOAP y REST.

Ambas opciones tienen diferentes características pero el objetivo final es el mismo, enviar información entre un cliente y un servidor.
___________________________________________________________________________________________________________________________________________

						DIFERENCIAS ENTRE SOAP Y REST
*protocolo*
Una gran diferencia es que SOAP es un protocolo, mientras que REST es una arquitectura que funciona sobre el protocolo HTTP

*desarrollo*
esarrollar un servicio SOAP requiere de más tiempo, tanto para el cliente como para el servidor, ya que debemos crear un fichero .wsdl el cual es un XML que contiene los datos que necesita y la dirección de donde esta ese servicio web. 
El formato `.wsdl` nos permite además añadir un dtd el cual puede validar todos los campos del xml antes de enviar el mensaje. 


Por otra parte en REST funciona por el protocolo HTTP lo que implica que para recibir/enviar información debemos hacerlo a través de peticiones web, a través de la URL o utilizando el cuerpo del mensaje.
Para el cuerpo del mensaje utilizamos Json o XML. Pero a diferencia de SOAP, todas las validaciones serán en el servidor. 

Por estos motivos el desarrollo de una API REST es mucho más rápido que el de un servicio web SOAP.

Por supuesto SOAP proviene de ventajas en otros aspectos, Por ejemplo, es capaz de mantener el estado entre varias request, mientras que en REST cada reques es individual. 

Cuando creamos APIs debemos crear los endpoint con CRUD en mente.


							 Qué es CRUD?

CRUD es un acronimo que hace referencia a sus siglas como 

Create (crear) para el que utilizaremos el método HTTP POST.
Read (leer) Para el que se utiliza el método HTTP GET.
Update (actualizar) para el que utilizaremos HTTP PUT.
Delete (eliminar) Para el que utilizaremos HTTP DELETE.

Cuando creamos endpoints para una API lo hacemos en un controller
crearemos una clase controlador EjemploController y le añadiremos el Atributo [ApiController]  y debemos importar la librería using Microsoft.AspNetCore.Mvc;

Y ahora solo nos queda la creación de los endpoints tanto para leer como para escribir.
___________________________________________________________________________________________________________________________________________
			
		Creación de un endpoint GET en C#

Un endpoint GET es el que utilizaremos para leer y es muy sencillo,
 únicamente debemos crear un método, y decorar este método 
bien sean los atributos `[HttpGet]` para indicar el método  HTTP para utilizar junto con `[Route(“ruta”)]` para indicar la ruta
 o directamente [HttpGet(“ruta”)] que nos permite indicar el método HTTP y la ruta que el navegador va a necesitar para ser llamado.

___________________________________________________________________________________________________________________________________________

.NET Framework, .NET Core y .NET son tres implementaciones de la plataforma .NET de Microsoft, cada una con sus propias características y usos.

.NET Framework: Es la implementación original de .NET, lanzada en 2002. 
Está diseñada principalmente para aplicaciones de Windows y proporciona un conjunto completo de bibliotecas y APIs para el desarrollo.
 Sin embargo, .NET Framework solo se ejecuta en sistemas operativos Windows.

.NET Core: Lanzado en 2016, .NET Core es una versión más ligera y modular de .NET
 A diferencia de .NET Framework, .NET Core es multiplataforma, lo que significa que puede ejecutarse en varios sistemas operativos, como Windows, macOS y Linux
.NET Core también es completamente de código abierto
Además, .NET Core puede estar instalado a nivel de equipo, de usuario o incluso a nivel de aplicación

A nivel de equipo: Esto significa que .NET Core se instala en una ubicación central en el sistema.
 generalmente en una carpeta del sistema y está disponible para todos los usuarios y aplicaciones en ese sistema.
 Este es el método de instalación más común y es el que se utiliza cuando instalas .NET Core a través de un instalador oficial de Microsoft.

A nivel de usuario: En este caso .NET Core se instala en una ubicación específica para un usuario individual.
 como la carpeta del usuario. Esto permite a ese usuario tener su propia versión de .NET Core sin afectar a otros usuarios en el mismo sistema.

A nivel de aplicación: Aquí, .NET Core se instala junto con una aplicación específica y solo se utiliza para esa aplicación.
 Esto puede ser útil si tu aplicación requiere una versión específica de .NET Core que no quieres instalar a nivel de sistema o de usuario
 Este método de instalación también se conoce como "auto-contenido".

A nivel de equipo: Imagina que estás en una empresa donde varios desarrolladores trabajan en diferentes proyectos en la misma máquina.
 En este caso, puedes instalar .NET Core en una ubicación central en el sistema, como C:\Program Files\dotnet\  y todos los desarrolladores pueden acceder a él para sus respectivos proyectos.

A nivel de usuario: Supongamos que compartes tu ordenador personal con otros miembros de tu familia y solo tú eres desarrollador.
 En este caso, puedes instalar .NET Core en tu directorio de usuario, como C:\Users\TuNombre\dotnet\  para que solo tú puedas acceder a él y no afecte a otros usuarios del sistema.

A nivel de aplicación: Digamos que estás desarrollando una aplicación que será distribuida a varios usuarios y quieres asegurarte de que la aplicación siempre use una versión específica de .NET Core
 independientemente de lo que el usuario tenga instalado en su sistema. 
En este caso, puedes incluir .NET Core con tu aplicación (en la misma carpeta que tu aplicación) para que se use específicamente para esa aplicación. Esto se conoce como una aplicación autocontenida.



___________________________________________________________________________________________________________________________________________

JWT:
Un JSON Web Token (JWT) es un token de acceso estandarizado que permite el intercambio seguro de datos entre dos partes
 Un JWT firmado consta de tres partes, todas ellas codificadas en Base64 y separadas por un punto.

el hash se refiere a la firma digital que se utiliza para verificar la autenticidad del token
La firma se genera utilizando un algoritmo de hash, que toma los datos del encabezado y la carga útil del JWT, junto con una clave secreta, y produce un hash único.
Cuando el servidor recibe un JWT, puede generar su propio hash utilizando los mismos datos y la misma clave secreta.
 Si el hash generado por el servidor coincide con el hash en el JWT, el servidor puede confiar en que el JWT es auténtico y no ha sido manipulado.

Header (Cabecera): El header consta generalmente de dos valores y proporciona información importante sobre el token.
 Contiene el tipo de token y el algoritmo de la firma y cifrado utilizados

Payload (Carga útil): El campo payload de JSON Web Token contiene la información real que se transmitirá a la aplicación
  Aquí se definen algunos estándares que determinan qué datos se transmiten y cómo.

La información se proporciona como pares key/value (clave-valor); las claves se denominan claims en JWT.

Signature (Firma): La firma se utiliza para verificar que el remitente del JWT es quien dice ser y para asegurar que el mensaje no ha sido cambiado en el camino.
 Esta codificación solo será efectiva si se utiliza una clave secreta que debe ser conocida solamente por la aplicación en cuestión.

Es importante recordar que los JWT pueden ser decodificados por cualquier sin necesidad de disponer de las claves privadas.
 por esta razón, nunca se debe incluir información sensible como contraseñas en los mismos.


Las claims, la signature y el algoritmo de hasheo son partes fundamentales de un JSON Web Token (JWT)12:

Claims: Las claims son piezas de información que se afirman sobre un sujeto
. En un JWT, una claim aparece como un par nombre/valor donde el nombre siempre es una cadena y el valor puede ser cualquier valor JSON
 Por ejemplo el siguiente objeto JSON contiene tres claims (sub, name, admin):
{
  "sub": "1234567890",
  "name": "Coria Ezequiel",
  "admin": true
}

Signature:  Se forma utilizando el encabezado codificado, la carga útil codificada y una contraseña.
 Todo esto está debidamente codificado en el formato que se especificó en el encabezado.
 Esta signature se utiliza para verificar que el mensaje no haya sido alterado.

Algoritmo de hasheo: El algoritmo de hasheo se especifica en el encabezado del JWT.

En cuanto a dónde guardar el salt/secret:

 hay varias opciones dependiendo de tus necesidades y del entorno en el que estés trabajando.
 Algunas opciones comunes incluyen:

En el servidor: Puedes guardar el salt/secret en el servidor.
 Esto es seguro ya que solo el servidor conoce el salt/secret y lo utiliza para generar y verificar los JWT.

En una variable de entorno: Otra opción es guardar el salt/secret en una variable de entorno en el servidor. 
Esto puede ser útil si estás trabajando en un entorno de desarrollo y no quieres exponer el salt/secret en tu código.
En un servicio de almacenamiento seguro: También puedes considerar el uso de un servicio de almacenamiento seguro
 como AWS Secrets Manager o Azure Key Vault, para almacenar el salt/secret.
Es importante tener en cuenta que el salt/secret debe mantenerse privado y seguro en todo momento, ya que cualquier persona con acceso al salt/secret podría generar JWT válidos


___________________________________________________________________________________________________________________________________________

			AUTENTICACION Y AUTORIZACIÓN:

En .NET, la autenticación y la autorización son dos componentes fundamentales para la seguridad de las aplicaciones

Autenticación: Es el proceso de obtener credenciales de identificación. como el nombre y la contraseña de un usuario, y validar esas credenciales en una autoridad.
 La entidad que envió las credenciales se considera una identidad autenticada si las credenciales son válidas.

En .NET el mecanismo principal para identificar a los usuarios es el sistema de pertenencia a ASP.NET Core Identity.
 que almacena la información del usuario en un almacén de datos configurado por el desarrollador.

Autorización: Una vez establecida una identidad. Un proceso de autorización determina si esa identidad tiene acceso a un recurso determinado.
 La autorización implica conceder permiso a una entidad de seguridad autenticada para realizar una acción o acceder a un recurso.
En .NET la autorización se puede implementar utilizando un modelo basado en roles o un modelo basado en directivas.

 La autenticación se preocupa simplemente de identificar quién es el usuario
 mientras que la autorización define lo que un usuario determinado puede hacer dentro de la aplicación
___________________________________________________________________________________________________________________________________________
		
			CONSTRUCTOR

Un constructor en C# es un método especial de una clase que se ejecuta automáticamente cuando se crea una instancia de esa clase.
 Su propósito principal es inicializar el objeto y establecer su estado inicial.
 algunos detalles importantes sobre los constructores en C#:

Los constructores tienen el mismo nombre que la clase.
Una clase puede tener varios constructores que toman diferentes argumentos.
Los constructores permiten al programador establecer valores predeterminados, limitar la creación de instancias y escribir código flexible y fácil de leer.
Un constructor que no toma ningún parámetro se denomina constructor sin parámetros.
Los constructores sin parámetros se invocan cada vez que se crea una instancia de un objeto mediante el operador new y no se especifica ningún argumento en new.
C#  introduce el concepto de constructores principales, que especifican parámetros que se deben proporcionar para inicializar un objeto nuevo.

___________________________________________________________________________________________________________________________________________

					ENTIDADES Y Dto.

Las entidades y los objetos de transferencia de datos (DTO) son dos conceptos utilizados en la programación
 especialmente en el diseño de software orientado a objetos y en la arquitectura de aplicaciones.


Propósito: Las entidades, también conocidas como objetos de negocio, representan conceptos del dominio del problema y contienen la lógica de negocio
 Por otro lado, los DTO son objetos simples que se utilizan para transferir datos entre procesos o componentes de una aplicación

Persistencia: Las entidades suelen estar mapeadas a tablas en una base de datos y se utilizan para manipular datos.
 Los DTO, en cambio, no están diseñados para ser persistentes.



Contenido: Las entidades pueden contener métodos de negocio y relaciones con otras entidades.
 Los DTO son más planos y suelen contener solo propiedades.


Uso: Las entidades se utilizan en todas las capas de una aplicación
 mientras que los DTO se utilizan principalmente para el transporte de datos entre la capa de presentación y la capa de negocio o entre diferentes sistemas.

Composición: Un DTO puede combinar propiedades de varias entidades



Cuando nos referimos a capas es una abstracción de responsabilidades. 
Además, la arquitectura establece reglas de cómo se deben comunicar las capas.
 cada capa puede funcionar y evolucionar independientemente de las otras.
consideremos una aplicación de comercio electrónico.
 La capa de presentación muestra productos a los usuarios.
 la capa de lógica de negocio maneja el carrito de compras.
 y la capa de acceso a datos interactúa con la base de datos para recuperar y almacenar información del producto.
si decidimos cambiar la estructura de la base de datos y mover algunos datos a un nuevo esquema:
 Aunque la capa de acceso a datos puede manejar la mayoría de los cambios:
la capa de lógica de negocio puede necesitar ser actualizada para reflejar estos cambios (ya que depende de la estructura de datos,
para funcionar correctamente)
Del mismo modo la capa de presentación puede necesitar ser actualizada
 si la forma en que se recuperan los datos afecta a cómo se muestran.


Primera regla 
Cada capa debe tener una responsabilidad única.
las capas deben estar perfectamente delimitadas de que se ocupa cada una de ellas.
podemos tener una capa de “presentación” que será la encargada de atender los eventos del cliente y encargada de representar la información
 podemos tener la capa de “acceso a datos” que será la encargada de guardar y acceder a los datos. 

Segunda regla 
Las capas deben respetar una estructura jerárquica estricta.
cada capa puede comunicarse sólo con la que está debajo suyo(pero no al revez)
una clase ubicada en la capa de presentación puede llamar a un método ubicado en la capa de acceso a datos
pero nunca la capa de acceso a datos puede llamar a un método de la capa de presentación. 
Y cuando nos referimos a la próxima más baja significa que no se puede saltar capas.

Ventajas 
Es fácil testear cada capa por separado debido a la separación clara de responsabilidades que existe entre ellas. 
Al momento de hacer un cambio:
si se implementó bien la separación de responsabilidad, este cambio solo debe impactar a la capa responsable y no a todas. 
Esto se conoce como desacople. 

Desventajas 
Si se implementaron demasiadas capas el rendimiento de la aplicación puede verse afectado  
Ciertas operaciones al ser modificadas pueden afectar a todas las capas, haciendo visible que no existe un 100% de desacople entre estas. 



 la arquitectura de 3 capas es bastante utilizada y es muy útil para entender la separación de responsabilidades de las capas.
Presentación
 Atiende los eventos del cliente y representa los datos para el mismo. 
Teniendo en cuenta que el cliente puede ser un humano u otro sistema
 esta capa será encargada en caso del humano de atender los clics en un HTML y de renderizar la información de manera visual. 
 En caso de que sea otro sistema puede atender peticiones rest
 y devolver información en un formato estructurado (json, xml, etc) que es más fácil de interpretar por un sistema.

Lógica de negocio
 En esta capa se encuentra todo lo que refiere a las reglas que se encuentran en el negocio: requerimientos funcionales de nuestro sistema
 si se tiene un alta de usuario esta capa debe proveer el medio para altaDeUsuario y dentro del método se debe realizar todos los pasos para dar de alta un usuario (enviar mail, validar nombre, etc).

Acceso a datos
 Mediante esta capa podremos obtener o guardar los datos que utilizará nuestra aplicación.
Observar que no habla de cómo se realiza la persistencia, si es en base de datos o en archivo o etc, solo habla de acceso a datos.
 Por ejemplo, esta capa debería proveer un medio para poder guardar el usuario y otro para obtenerlo. 



Si logramos realizar esta separación de responsabilidades podemos notar como a una capa no le interesa cómo está implementada la otra
a. Así yo puedo reemplazar las implementaciones de las capas, pero esto no afectaría a las demás



				Web API

El término API es una abreviatura de Application Programming Interfaces,
interfaz de programación de aplicaciones.
 Se trata de un conjunto de definiciones y protocolos que se utiliza para desarrollar e integrar el software de las aplicaciones
permitiendo la comunicación entre dos aplicaciones de software a través de un conjunto de reglas.

podemos hablar de una API como una especificación formal que establece cómo un módulo de un software se comunica o interactúa con otro para cumplir una o muchas funciones.
dependiendo de las aplicaciones que las vayan a utilizar, y de los permisos que les dé el propietario de la API a los desarrolladores de terceros.

Una de las principales funciones de las API es poder facilitar el trabajo a los desarrolladores
Con ello, no será necesario tener que reinventar la rueda con cada servicio que se crea, ya que podrás utilizar piezas o funciones que otros ya han creado-

____________________________________________________________________________________________________________________________

			HTTP REQUEST y RESPONSE 
son dos conceptos básicos en el desarrollo web.
HTTP significa  HyperText Transfer Protocol.
 Esta es la forma de comunicación de datos básica en Internet. 
La comunicación de datos empieza con un request enviado del cliente, y termina con la respuesta del servidor web.
1.Un sitio web que empieza con la URL http://
 es entrado en un navegador web de la computadora del cliente.
2.El navegador envía un request al servidor web que está hospedado en el website.
3.El servidor web regresa una respuesta
 como un página de HTML, o algún otro formato de documento al navegador (puede ser un mp4, mp3, pdf, doc, entre otros soportados por el navegador)
4. El navegador despliega el response del servidor al usuario. 

No todas las requests se hacen desde los navegadores de usuarios finales.
 de hecho muchas peticiones se hacen desde aplicaciones(Discord, Steam, Whatsapp, Instagram)
 o incluso de dispositivos IoT(Google Home, Alarmas).


Las peticiones o requests se hacen siempre a un endpoint:
 un punto de acceso de una API que procesa dicha solicitud y responde de acuerdo a su implementación interna.
 Aquí se puede ver que las APIs toman claramente la encapsulación de la POO




HTTP Request Structure from Client

Un HTTP request se compone de:

Método: GET, POST, PUT, DELETE (Indica que tipo de request es)
Path: la URL que se solicita   (Donde se encuentra el resource)
Protocolo: contiene HTTP y su versión.
Headers: Son esquemas de key: (value que contienen información sobre el HTTP request y el navegador)
 Aquí también se encuentran los datos de las cookies. La mayoría de los headers son opcionales.
Body: Si se envía información al servidor a través de POST o PUT, ésta va en el body.


HTTP Response Structure from Web Server
Una vez que el navegador envía el HTTP request:
 el servidor responde con un HTTP response
 compuesto por:

Protocolo. Contiene HTTP y su versión
Status code: El código de respuesta
( por ejemplo: 200 OK, que significa que el GET request ha sido satisfactorio
 y el servidor devolverá los contenidos del documento solicitado. 
Otro ejemplo es 404 Not Found, el servidor no ha encontrado el resource solicitado)
Headers: Contienen información sobre el software del servidor, cuando se modificó por última vez el resource solicitado.
Body: Si el servidor devuelve información que no sean headers ésta va en el body.

________________________________________________________________________________________________________________

			EF

Entity Framework (EF) es una solución de Microsoft para un Mapeador Relacional de Objetos (ORM) en aplicaciones .NET
 En términos sencillos, EF es como un puente que conecta tu código con la base de datos.

Imagina que estás construyendo una aplicación y necesitas almacenar y recuperar datos de una base de datos.
 Normalmente, tendrías que escribir mucho código para interactuar con la base de datos:
 convertir los datos en objetos que tu código pueda entender
 y luego convertir los cambios en tus objetos de nuevo a un formato que la base de datos pueda entender.

Aquí es donde entra en juego Entity Framework.
 EF te permite trabajar con los datos en forma de objetos y propiedades específicos de tu dominio.
 como clientes y direcciones de clientes sin tener que pensar en las tablas de la base de datos y las columnas en las que se almacenan estos datos

Por lo tanto, EF te ayuda a reducir la cantidad de código que necesitas escribir para estas tareas de acceso y gestión de datos
 permitiéndote centrarte más en la lógica de tu aplicación.

__________________________________________________________________________________________________________________________


Patrón repository

Está diseñado para crear una capa de abstracción entre la capa de acceso a datos y la capa de lógica de negocios(de una aplicación). 
Implementar estos patrones puede ayudar a aislar la aplicación de cambios en el almacén de datos
y puede facilitar la realización de pruebas unitarias automatizadas o el desarrollo controlado por pruebas (TDD).

Este patrón permite crear una clase o varias en donde estén definidos todos los métodos que interactúen con la base de datos,
 esta clase consume el contexto de la base de datos.

Otro de los aspectos fundamentales
 es que estas clases que se encarga de los métodos de datos implementando una interfaz en donde se definen la firma de los métodos(tipo nombre y parámetros del método) que componen a la clase que hace de repository. Si tengo dividido el repository en varias clases entonces debo definir una interfaz por clase y hacer que dicha clase implemente la interfaz.

La interfaz tiene la utilidad de que si en un futuro quiero implementar otro repository ya sea que porque tengo otro contexto debido a que algunos datos se manejan en otra base datos para inteligencia de negocio o por motivos de disponibilidad, entonces solo hace falta implementar la misma interfaz en la nueva clase repository análoga y de esta manera nos aseguramos que la clase contenga la totalidad de los métodos definidos de la capa de datos y definidos de la misma manera así nos evitamos inconvenientes en las capas lógicas que utilizan estos métodos


El patrón de repositorio sugiere que todas las operaciones relacionadas con la base de datos deben estar en una clase o clases separadas
 conocidas como repositorios. 

Cada método en un repositorio representa una consulta a la base de datos.

Ahora, una interfaz es como un contrato que define qué métodos debe tener una clase.
 Cuando una clase implementa una interfaz, está prometiendo que incluirá todos los métodos definidos en esa interfaz.

Entonces:  cada clase de repositorio debe implementar una interfaz.
 Esta interfaz define la “firma” de los métodos que la clase de repositorio debe tener.
 La firma de un método incluye el tipo de retorno del método, el nombre del método y los parámetros del método.

Si tienes varios repositorios (por ejemplo, un repositorio de Usuarios, un repositorio de Productos, etc.)
 entonces cada uno de estos repositorios debería tener su propia interfaz. 
Por ejemplo, la interfaz del repositorio de Usuarios podría definir métodos como ObtenerUsuarioPorId(int id)
 GuardarUsuario(Usuario usuario), etc.

La ventaja de esto es que si en el futuro necesitas cambiar la forma en que accedes a la base de datos 
(por ejemplo, si cambias de una base de datos SQL a una base de datos NoSQL), 
solo necesitas crear nuevas clases de repositorio que implementen las mismas interfaces. 
De esta manera, el resto de tu código no necesita cambiar porque todavía está llamando a los mismos métodos definidos en las interfaces. 
Esto es lo que se conoce como desacoplamiento:
 el código de tu aplicación no está directamente ligado a un tipo específico de base de datos.

Una “capa de abstracción” en este contexto se refiere a la idea de ocultar los detalles técnicos o complejos
 y proporcionar solo la funcionalidad necesaria al usuario o a la capa superior.

En el caso del patrón de repositorio: la “capa de abstracción” es la clase de repositorio.
Esta clase oculta los detalles de cómo se accede a la base de datos y cómo se realizan las operaciones de la base de datos.
 En lugar de tener que escribir código SQL complejo en tu lógica de negocio,
 puedes simplemente llamar a métodos en la clase de repositorio como ObtenerUsuarioPorId(int id) o GuardarUsuario(Usuario usuario).
 Estos métodos manejan todos los detalles de la interacción con la base de datos.

Por lo tanto, la capa de repositorio es una “capa de abstracción” porque abstrae o esconde los detalles de la base de datos
 permitiéndote trabajar a un nivel más alto de abstracción.
 Esto hace que tu código sea más fácil de entender, más fácil de mantener y más flexible ante cambios en la base de datos.



Una clase de repositorio se encarga de la interacción directa con la base de datos.
 Proporciona métodos para recuperar, crear, actualizar y eliminar datos en la base de datos. 
cada método representa una operación específica de la base de datos.


La interfaz es  un contrato que define qué métodos debe tener una clase. 
No tiene ninguna implementación de los métodos
 solo las firmas de los métodos ( los nombres de los métodos, los tipos de los parámetros y los tipos de retorno).

La clase de repositorio es una clase concreta que implementa esta interfaz. 
Proporciona la implementación real de los métodos definidos en la interfaz. 
la clase de repositorio escribe el código que dice exactamente cómo se deben realizar las operaciones de la base de datos.

Una clase de repositorio se encarga de la interacción directa con la base de datos.
 Proporciona métodos para recuperar, crear, actualizar y eliminar datos en la base de datos.
 Cada método representa una operación específica de la base de datos.

Una clase de servicios: contiene la lógica de negocio de la aplicación.
 Esta lógica de negocio puede implicar operaciones más complejas 
que implican múltiples pasos o la coordinación de varias operaciones de la base de datos.
 Las clases de servicios a menudo utilizan las clases de repositorio para realizar estas operaciones de la base de datos.

Por lo tanto
 aunque las clases de repositorio y las clases de servicios pueden trabajar juntas y ambas son importantes en una aplicación,
 tienen responsabilidades diferentes y no son intercambiables.

__________________________________________________________________________________________________________________________

		Model View Controller (MVC)
 MVC es una propuesta de arquitectura del software utilizada para separar el código por sus distintas responsabilidades.
 manteniendo distintas capas que se encargan de hacer una tarea muy concreta, lo que ofrece beneficios diversos.

MVC se usa inicialmente en sistemas donde se requiere el uso de interfaces de usuario
( aunque el mismo patrón de arquitectura se puede utilizar para distintos tipos de aplicacione)
urge de la necesidad de crear software más robusto con un ciclo de vida más adecuado
 donde se potencie la facilidad de mantenimiento, reutilización del código y la separación de conceptos.

Su fundamento es la separación del código en tres capas diferentes, acotadas por su responsabilidad
en lo que se llaman Modelos, Vistas y Controladores

MVC  está para ayudarnos a crear aplicaciones con mayor calidad.

...

Modelos
Es la capa donde se trabaja con los datos.
 contendrá mecanismos para acceder a la información y también para actualizar su estado.
 Los datos los tendremos habitualmente en una base de datos.
 por lo que en los modelos tendremos todas las funciones que accederán a las tablas
 y harán los correspondientes selects, updates, inserts, etc.
 cabe mencionar que cuando se trabaja con MVC lo habitual también es utilizar otras librerías o algún ORM como Entity Framework,
 que nos permiten trabajar con abstracción de bases de datos y persistencia en objetos.
en vez de usar directamente sentencias SQL
que suelen depender del motor de base de datos con el que se esté trabajando
 se utiliza un dialecto de acceso a datos basado en clases y objetos.

Vistas
Las vistas contienen el código de nuestra aplicación que va a producir la visualización de las interfaces de usuario.
  el código que nos permitirá renderizar los estados de nuestra aplicación en HTML.
 En las vistas nada más tenemos los códigos HTML y PHP que nos permite mostrar la salida.

En la vista generalmente trabajamos con los datos( no se realiza un acceso directo a éstos)
 Las vistas requerirán los datos a los modelos y ellas se generará la salida, tal como nuestra aplicación requiera.

Controladores
Contiene el código necesario para responder a las acciones que se solicitan en la aplicación.
 como visualizar un elemento, realizar una compra, una búsqueda de información, etc.

En realidad es una capa que sirve de enlace entre las vistas y los modelos.
 respondiendo a los mecanismos que puedan requerirse para implementar las necesidades de nuestra aplicación. 
Sin embargo, su responsabilidad no es manipular directamente datos, ni mostrar ningún tipo de salida
 sino servir de enlace entre los modelos y las vistas para implementar las diversas necesidades del desarrollo.

 				...

El usuario(a través del browser) realiza una solicitud a nuestro sitio web.
 Generalmente estará desencadenada por acceder a una página de nuestro sitio. Esa solicitud le llega al controlador.
El controlador se comunica tanto con modelos como con vistas. 
A los modelos les solicita datos o les manda realizar actualizaciones de los datos. 
A las vistas les solicita la salida correspondiente:
 una vez se hayan realizado las operaciones pertinentes según la lógica del negocio.
Para producir la salida, en ocasiones las vistas pueden solicitar más información a los modelos. 
En ocasiones, el controlador será el responsable de solicitar todos los datos a los modelos y de enviarlos a las vistas, 
haciendo de puente entre unos y otros.
 Sería corriente tanto una cosa como la otra, todo depende de nuestra implementación.



Lógica de negocio / Lógica de la aplicación
Hay un concepto que se usa mucho cuando se explica el MVC que es la "lógica de negocio".
 Es un conjunto de reglas que se siguen en el software para reaccionar ante distintas situaciones.
 En una aplicación el usuario se comunica con el sistema por medio de una interfaz,
 pero cuando acciona esa interfaz para realizar acciones con el programa:
 se ejecutan una serie de procesos que se conocen como la lógica del negocio.
 Este es un concepto de desarrollo de software en general.

La lógica del negocio, aparte de marcar un comportamiento cuando ocurren cosas dentro de un software,
 también tiene normas sobre lo que se puede hacer y lo que no se puede hacer.
 Eso también se conoce como reglas del negocio.

 Bien, pues en el MVC la lógica del negocio queda del lado de los modelos.

 Ellos son los que deben saber cómo operar en diversas situaciones
y las cosas que pueden permitir que ocurran en el proceso de ejecución de una aplicación. 

Es decir que en MVC gran parte de la lógica se maneja fuera del controlador.
esto puede ser en la capa de modelos o bien creando una nueva capa con la lógica de negocio
(Esta es la diferencia de la capa de datos en la arquitectura de 3 capas)

Por ejemplo, pensemos en un sistema que implementa usuarios.
 Los usuarios pueden realizar comentarios. 
Pues si en un modelo nos piden eliminar un usuario nosotros debemos borrar todos los comentarios que ha realizado ese usuario también. 
Esto no es una responsabilidad del controlador 
y forma parte de lo que se llama la lógica del negocio y se ejecutará en la capa que hayamos definido.

Sin embargo existe otro concepto que se usa en la terminología del MVC que es la "lógica de aplicación"
 que es algo que pertenece a los controladores.
 Por ejemplo, cuando me piden ver el resumen de datos de un usuario.
 Esa acción le llega al controlador, que tendrá que acceder al modelo del usuario para pedir sus datos.
 Luego llamará a la vista apropiada para poder mostrar esos datos del usuario. 
Si en el resumen del usuario queremos mostrar los artículos que ha publicado dentro de la aplicación:
 quizás el controlador tendrá que llamar al modelo de artículos
 pedirle todos los publicados por ese usuario y con ese listado de artículos invocar a la vista correspondiente para mostrarlos.
 Todo ese conjunto de acciones que se realizan invocando métodos de los modelos y mandando datos a las vistas
forman parte de la "lógica de la aplicación"

En resumen, en MVC la lógica se divide en dos capas distintas
 cierta lógica (lógica de negocios) está presente en la capa de Modelos o en la capa que hayamos definido para ella
 y cierta lógica en la capa de controladores(lógica de aplicación).
 Es importante destacar que en la capa de vistas nunca hay ningún tipo de lógica.



________________________________________________________________________________________________________________

Ventajas de Utilizar Inyección de Dependencias

Flexible:
 No hay necesidad de tener un código de búsqueda en la lógica de negocio.
Elimina el acoplamiento entre módulos

Testable:
No se necesita un espacio específico de testeo.
Testeo automático como parte de las construcciones.

Mantenible:
Permite la reutilización en diferentes entornos de aplicaciones modificando los archivos de configuración en lugar del código.
Promueve un enfoque coherente en todos aplicaciones y equipos


CLASE EN LA QUE SE INYECTA

public class LogicaNegocio
{
    AccesDataCliente _dataAccess;

    public LogicaNegocio(AccesDataCliente custDataAccess)
    {
        _dataAcces = custDataAccess;
    }

   public string ProcesoDataCliente(int id)
    {
        return _dataAcces.GetDataCliente(id);
    }
}
—------------------------------------------------------
public interface IAccesoDataCliente
{
    string GetDataCliente(int id);
}
—------------------------------------------------------
CLASE A INYECTAR

public class AccesDataCliente: IAccesoDataCliente
{
   public AccesDataCliente()
    {
    }




